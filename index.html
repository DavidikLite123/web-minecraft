<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>VoxelCraft â€” Multiplayer</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{overflow:hidden;background:#000;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;touch-action:none;user-select:none;-webkit-user-select:none;-webkit-tap-highlight-color:transparent}
canvas{display:block}

/* â•â•â• MENU â•â•â• */
#menuScreen{position:fixed;inset:0;z-index:9000;display:flex;flex-direction:column;align-items:center;justify-content:center;color:#fff;overflow:hidden}
#menuBg{position:absolute;inset:0;background:linear-gradient(135deg,#0d1117 0%,#161b22 50%,#0d1117 100%)}
#menuBg::before{content:'';position:absolute;inset:0;background:url("data:image/svg+xml,%3Csvg width='60' height='60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h10v10H0zM20 0h10v10H20zM40 0h10v10H40zM10 10h10v10H10zM30 10h10v10H30zM50 10h10v10H50zM0 20h10v10H0zM20 20h10v10H20zM40 20h10v10H40zM10 30h10v10H10zM30 30h10v10H30zM50 30h10v10H50zM0 40h10v10H0zM20 40h10v10H20zM40 40h10v10H40zM10 50h10v10H10zM30 50h10v10H30zM50 50h10v10H50z' fill='rgba(255,255,255,.015)'/%3E%3C/svg%3E");animation:bgScroll 20s linear infinite}
@keyframes bgScroll{to{background-position:60px 60px}}
#menuContent{position:relative;z-index:1;display:flex;flex-direction:column;align-items:center;width:100%}
.logo{font-size:clamp(2.5rem,10vw,5rem);font-weight:900;letter-spacing:4px;background:linear-gradient(135deg,#58d68d,#3498db,#58d68d);background-size:200% 200%;-webkit-background-clip:text;-webkit-text-fill-color:transparent;animation:logoShine 3s ease infinite;filter:drop-shadow(0 0 40px rgba(88,214,141,.2))}
@keyframes logoShine{0%,100%{background-position:0% 50%}50%{background-position:100% 50%}}
.logo-sub{color:rgba(255,255,255,.35);font-size:.85rem;letter-spacing:6px;margin-top:2px;margin-bottom:32px;text-transform:uppercase}

/* Cards */
.card{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.07);border-radius:20px;padding:32px;width:min(420px,92vw);backdrop-filter:blur(20px);-webkit-backdrop-filter:blur(20px);box-shadow:0 8px 32px rgba(0,0,0,.3)}
.card label{display:block;color:rgba(255,255,255,.45);font-size:.75rem;font-weight:600;letter-spacing:1px;text-transform:uppercase;margin-bottom:6px;margin-top:18px}
.card label:first-child{margin-top:0}
.card input{width:100%;padding:14px 18px;border-radius:12px;border:1px solid rgba(255,255,255,.1);background:rgba(255,255,255,.05);color:#fff;font-size:1rem;outline:none;transition:all .25s}
.card input:focus{border-color:rgba(88,214,141,.5);box-shadow:0 0 0 3px rgba(88,214,141,.1)}
.card input::placeholder{color:rgba(255,255,255,.2)}
.divider{height:1px;background:rgba(255,255,255,.06);margin:22px 0}

/* Buttons */
.btn{width:100%;padding:15px;margin-top:10px;border:none;border-radius:14px;font-size:1rem;font-weight:700;cursor:pointer;transition:all .2s;color:#fff;position:relative;overflow:hidden;letter-spacing:.5px}
.btn:active{transform:scale(.97)}
.btn::after{content:'';position:absolute;inset:0;background:linear-gradient(rgba(255,255,255,.1),transparent);pointer-events:none}
.btn-green{background:linear-gradient(135deg,#27ae60,#2ecc71);box-shadow:0 4px 20px rgba(46,204,113,.3)}
.btn-blue{background:linear-gradient(135deg,#2980b9,#3498db);box-shadow:0 4px 20px rgba(52,152,219,.3)}
.btn-purple{background:linear-gradient(135deg,#8e44ad,#9b59b6);box-shadow:0 4px 20px rgba(155,89,182,.3)}
.btn-dark{background:rgba(255,255,255,.06);box-shadow:none;font-weight:400;font-size:.85rem;color:rgba(255,255,255,.6)}
.btn-orange{background:linear-gradient(135deg,#e67e22,#f39c12);box-shadow:0 4px 20px rgba(243,156,18,.3)}
.btn-icon{display:inline-flex;align-items:center;gap:8px;justify-content:center}

/* Room display */
#roomDisplay{display:none;margin-top:16px;padding:20px;background:rgba(88,214,141,.06);border:1px solid rgba(88,214,141,.15);border-radius:16px;text-align:center}
#roomDisplay .room-label{font-size:.7rem;color:rgba(255,255,255,.4);letter-spacing:2px;text-transform:uppercase}
#roomDisplay .room-id{font-size:2.8rem;font-weight:900;letter-spacing:12px;color:#58d68d;margin:8px 0;font-family:'Courier New',monospace}
#roomDisplay .room-hint{font-size:.75rem;color:rgba(255,255,255,.3)}
.copy-wrap{display:flex;gap:8px;margin-top:10px}
.copy-wrap .btn{flex:1;margin-top:0;padding:12px;font-size:.85rem}

#joinSection{display:none}
#joinSection input{text-align:center;font-size:1.6rem;letter-spacing:8px;text-transform:uppercase;font-family:'Courier New',monospace;font-weight:700}

#statusBar{margin-top:18px;text-align:center;font-size:.82rem;min-height:24px;color:rgba(255,255,255,.5)}
.status-dot{display:inline-block;width:8px;height:8px;border-radius:50%;margin-right:6px;vertical-align:middle}
.dot-loading{background:#f39c12;animation:pulse 1s ease infinite}
.dot-ok{background:#2ecc71}
.dot-err{background:#e74c3c}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.3}}

#playerList{margin-top:10px;font-size:.78rem;color:rgba(255,255,255,.35);text-align:center}

/* â•â•â• HUD â•â•â• */
#hud{position:fixed;top:0;left:0;z-index:100;pointer-events:none;width:100%;height:100%;display:none}
#crosshair{position:absolute;top:50%;left:50%;width:24px;height:24px;transform:translate(-50%,-50%)}
#crosshair::before,#crosshair::after{content:'';position:absolute;background:rgba(255,255,255,.8);border-radius:1px}
#crosshair::before{width:2px;height:18px;top:50%;left:50%;transform:translate(-50%,-50%)}
#crosshair::after{width:18px;height:2px;top:50%;left:50%;transform:translate(-50%,-50%)}
#coords{position:absolute;top:12px;left:12px;background:rgba(0,0,0,.5);color:rgba(255,255,255,.8);padding:6px 12px;border-radius:8px;font-size:.7rem;font-family:'Courier New',monospace;backdrop-filter:blur(4px)}
#netStatus{position:absolute;top:12px;right:12px;background:rgba(0,0,0,.5);color:#fff;padding:6px 12px;border-radius:8px;font-size:.75rem;display:flex;align-items:center;gap:6px;backdrop-filter:blur(4px)}
#blockName{position:absolute;bottom:68px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.55);color:#fff;padding:6px 18px;border-radius:10px;font-size:.8rem;white-space:nowrap;backdrop-filter:blur(4px)}

/* Hotbar */
#hotbar{position:absolute;bottom:8px;left:50%;transform:translateX(-50%);display:flex;gap:2px;pointer-events:auto}
.hs{width:44px;height:44px;background:rgba(0,0,0,.55);border:2px solid rgba(255,255,255,.12);border-radius:6px;display:flex;align-items:center;justify-content:center;cursor:pointer;position:relative;backdrop-filter:blur(4px);transition:border-color .15s,box-shadow .15s}
.hs.active{border-color:#58d68d;box-shadow:0 0 12px rgba(88,214,141,.4)}
.hs canvas{width:28px;height:28px;border-radius:3px;image-rendering:pixelated}
.hs .snum{position:absolute;top:1px;left:3px;font-size:.5rem;color:rgba(255,255,255,.35)}

/* â•â•â• CHAT â•â•â• */
#chatBox{position:fixed;bottom:62px;left:10px;z-index:300;width:min(360px,72vw);pointer-events:none}
#chatLog{max-height:150px;overflow-y:auto;display:flex;flex-direction:column;gap:2px;padding:4px}
#chatLog::-webkit-scrollbar{width:0}
.cmsg{background:rgba(0,0,0,.5);color:#fff;padding:3px 10px;border-radius:6px;font-size:.76rem;word-break:break-word;width:fit-content;max-width:100%;backdrop-filter:blur(4px);animation:chatIn .2s ease}
@keyframes chatIn{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:none}}
.cmsg .cn{font-weight:700}
#chatInputBox{display:none;margin-top:4px;pointer-events:auto}
#chatInput{width:100%;padding:10px 14px;border:1px solid rgba(88,214,141,.25);border-radius:10px;background:rgba(0,0,0,.7);color:#fff;font-size:.85rem;outline:none;backdrop-filter:blur(8px)}
#chatBtn{display:none;position:fixed;bottom:70px;left:10px;z-index:301;width:42px;height:42px;border-radius:50%;border:none;background:rgba(255,255,255,.1);color:#fff;font-size:1.1rem;pointer-events:auto;cursor:pointer;backdrop-filter:blur(4px)}

/* â•â•â• MOBILE â•â•â• */
#mobileUI{position:fixed;inset:0;z-index:200;pointer-events:none;display:none}
#joyZone{position:absolute;bottom:20px;left:16px;width:140px;height:140px;pointer-events:auto}
#joyBase{width:140px;height:140px;border-radius:50%;background:rgba(255,255,255,.05);border:2px solid rgba(255,255,255,.12);position:relative}
#joyKnob{width:56px;height:56px;border-radius:50%;background:rgba(255,255,255,.15);border:2px solid rgba(255,255,255,.2);position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}
.mb{pointer-events:auto;border:none;border-radius:50%;background:rgba(255,255,255,.08);border:2px solid rgba(255,255,255,.12);color:rgba(255,255,255,.7);font-weight:700;display:flex;align-items:center;justify-content:center;position:absolute;backdrop-filter:blur(4px);transition:background .1s}
.mb:active{background:rgba(255,255,255,.2)}
#mbJump{width:70px;height:70px;bottom:24px;right:20px;font-size:1.5rem}
#mbBreak{width:58px;height:58px;bottom:115px;right:92px;font-size:.8rem}
#mbPlace{width:58px;height:58px;bottom:115px;right:20px;font-size:.8rem}

/* â•â•â• PAUSE â•â•â• */
#pauseScreen{position:fixed;inset:0;z-index:8000;background:rgba(0,0,0,.75);display:none;flex-direction:column;align-items:center;justify-content:center;color:#fff;backdrop-filter:blur(6px)}
#pauseScreen h2{font-size:2rem;margin-bottom:20px;font-weight:300}
#pauseScreen .btn{width:220px}

/* â•â•â• RECONNECT OVERLAY â•â•â• */
#reconnectOverlay{position:fixed;top:60px;left:50%;transform:translateX(-50%);z-index:9999;background:rgba(231,76,60,.9);color:#fff;padding:12px 28px;border-radius:12px;font-size:.9rem;font-weight:600;display:none;backdrop-filter:blur(8px);box-shadow:0 4px 20px rgba(231,76,60,.3);animation:slideDown .3s ease}
@keyframes slideDown{from{opacity:0;transform:translateX(-50%) translateY(-20px)}to{opacity:1;transform:translateX(-50%) translateY(0)}}
</style>
</head>
<body>

<!-- MENU -->
<div id="menuScreen">
  <div id="menuBg"></div>
  <div id="menuContent">
    <div class="logo">VOXELCRAFT</div>
    <div class="logo-sub">Multiplayer Edition</div>
    <div class="card" id="mainCard">
      <label>ĞĞ¸ĞºĞ½ĞµĞ¹Ğ¼</label>
      <input id="inpNick" placeholder="Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ¸Ğ¼Ñ..." maxlength="16">
      <div class="divider"></div>
      <button class="btn btn-green btn-icon" id="btnHost">ğŸŒ Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‚ÑŒ Ğ¼Ğ¸Ñ€</button>
      <button class="btn btn-blue btn-icon" id="btnJoinShow">ğŸ”— ĞŸÑ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ñ‚ÑŒÑÑ</button>
      <div id="roomDisplay">
        <div class="room-label">ĞšĞ¾Ğ´ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹</div>
        <div class="room-id" id="roomId">----</div>
        <div class="room-hint">ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒÑ‚Ğµ ÑÑ‚Ğ¾Ñ‚ ĞºĞ¾Ğ´ Ğ´Ñ€ÑƒĞ³Ñƒ</div>
        <div class="copy-wrap">
          <button class="btn btn-dark" id="btnCopy">ğŸ“‹ ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ</button>
          <button class="btn btn-orange" id="btnStart">ğŸš€ Ğ˜Ğ³Ñ€Ğ°Ñ‚ÑŒ</button>
        </div>
      </div>
      <div id="playerList"></div>
    </div>
    <div class="card" id="joinSection">
      <label>ĞšĞ¾Ğ´ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹</label>
      <input id="inpRoom" placeholder="XXXX" maxlength="6">
      <button class="btn btn-purple btn-icon" id="btnConnect">âš¡ ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒÑÑ</button>
      <button class="btn btn-dark" id="btnBack">â† ĞĞ°Ğ·Ğ°Ğ´</button>
    </div>
    <div id="statusBar"></div>
  </div>
</div>

<!-- HUD -->
<div id="hud">
  <div id="crosshair"></div>
  <div id="coords">0, 0, 0</div>
  <div id="netStatus"><span class="status-dot dot-ok"></span><span id="netText">ğŸ‘¤ 1</span></div>
  <div id="blockName">Ğ¢Ñ€Ğ°Ğ²Ğ°</div>
  <div id="hotbar"></div>
</div>

<!-- CHAT -->
<div id="chatBox"><div id="chatLog"></div><div id="chatInputBox"><input id="chatInput" placeholder="Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ..." maxlength="200"></div></div>
<button id="chatBtn">ğŸ’¬</button>

<!-- MOBILE -->
<div id="mobileUI">
  <div id="joyZone"><div id="joyBase"><div id="joyKnob"></div></div></div>
  <button class="mb" id="mbJump">â¬†</button>
  <button class="mb" id="mbBreak">â›ï¸</button>
  <button class="mb" id="mbPlace">ğŸ§±</button>
</div>

<!-- PAUSE -->
<div id="pauseScreen">
  <h2>ĞŸĞ°ÑƒĞ·Ğ°</h2>
  <button class="btn btn-green" id="btnResume">â–¶ ĞŸÑ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ</button>
  <button class="btn btn-dark" id="btnQuit" style="margin-top:8px">ğŸšª Ğ’Ñ‹Ğ¹Ñ‚Ğ¸</button>
</div>

<!-- RECONNECT -->
<div id="reconnectOverlay">âš  Ğ¡Ğ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ñ‚ĞµÑ€ÑĞ½Ğ¾ â€” Ğ¿ĞµÑ€ĞµĞ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ...</div>

<script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFIG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CS = 16, CH = 64, RENDER_DIST = 4;
const GRAVITY = 28, JUMP_VEL = 9.5, MOVE_SPEED = 6, EYE_H = 1.62, BODY_R = 0.3;
const MOBILE = /Android|iPhone|iPad|iPod|webOS/i.test(navigator.userAgent) || ('ontouchstart' in window && innerWidth < 1100);
const NET_HZ = 10; // position updates per second

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BLOCK TYPES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const BT = {
  0:{n:'Ğ’Ğ¾Ğ·Ğ´ÑƒÑ…',s:false},
  1:{n:'Ğ¢Ñ€Ğ°Ğ²Ğ°',s:true},
  2:{n:'Ğ—ĞµĞ¼Ğ»Ñ',s:true},
  3:{n:'ĞšĞ°Ğ¼ĞµĞ½ÑŒ',s:true},
  4:{n:'Ğ”ĞµÑ€ĞµĞ²Ğ¾',s:true},
  5:{n:'Ğ›Ğ¸ÑÑ‚Ğ²Ğ°',s:true},
  6:{n:'ĞŸĞµÑĞ¾Ğº',s:true},
  7:{n:'Ğ’Ğ¾Ğ´Ğ°',s:false},
  8:{n:'Ğ”Ğ¾ÑĞºĞ¸',s:true},
  9:{n:'ĞšĞ¸Ñ€Ğ¿Ğ¸Ñ‡',s:true},
  10:{n:'Ğ‘ÑƒĞ»Ñ‹Ğ¶Ğ½Ğ¸Ğº',s:true}
};
const HOTBAR_BLOCKS = [1,2,3,4,5,6,8,9,10];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PROCEDURAL TEXTURES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const _tc = {};
function mkTex(id) {
  if (_tc[id]) return _tc[id];
  const S = 64, cv = document.createElement('canvas');
  cv.width = cv.height = S;
  const c = cv.getContext('2d');
  let sd = id * 9973 + 541;
  const R = () => { sd = (sd * 16807 + 11) % 2147483647; return (sd & 0x7fffffff) / 2147483647; };

  switch(id) {
    case 1: // Grass top
      c.fillStyle='#4a8c32'; c.fillRect(0,0,S,S);
      for(let i=0;i<500;i++){c.fillStyle=`rgb(${55+R()*45|0},${100+R()*80|0},${30+R()*25|0})`;c.fillRect(R()*S|0,R()*S|0,1+R()*2|0,1+R()*2|0)}
      for(let i=0;i<100;i++){c.fillStyle=`rgba(${60+R()*30|0},${140+R()*50|0},${35+R()*20|0},.6)`;c.fillRect(R()*S|0,R()*S|0,1,2+R()*4|0)}
      break;
    case 11: // Grass side
      c.fillStyle='#7a5a2e'; c.fillRect(0,0,S,S);
      for(let i=0;i<400;i++){c.fillStyle=`rgba(${100+R()*50|0},${70+R()*40|0},${25+R()*20|0},.5)`;c.fillRect(R()*S|0,R()*S|0,2+R()*2|0,2+R()*2|0)}
      c.fillStyle='#4a8c32'; c.fillRect(0,0,S,7);
      for(let i=0;i<80;i++){c.fillStyle=`rgb(${45+R()*40|0},${100+R()*70|0},${25+R()*20|0})`;c.fillRect(R()*S|0,R()*7|0,2,2)}
      for(let i=0;i<25;i++){c.fillStyle='rgba(60,130,40,.65)';c.fillRect(R()*S|0,6,1,1+R()*4|0)}
      break;
    case 2: // Dirt
      c.fillStyle='#7a5a2e'; c.fillRect(0,0,S,S);
      for(let i=0;i<600;i++){c.fillStyle=`rgba(${90+R()*55|0},${65+R()*40|0},${20+R()*25|0},.5)`;c.fillRect(R()*S|0,R()*S|0,2+R()*3|0,2+R()*3|0)}
      for(let i=0;i<40;i++){c.fillStyle='rgba(50,30,10,.3)';c.fillRect(R()*S|0,R()*S|0,3+R()*2|0,3+R()*2|0)}
      break;
    case 3: // Stone
      c.fillStyle='#8a8a8a'; c.fillRect(0,0,S,S);
      for(let i=0;i<700;i++){const v=80+R()*80|0;c.fillStyle=`rgb(${v},${v},${v})`;c.fillRect(R()*S|0,R()*S|0,2+R()*4|0,2+R()*4|0)}
      for(let i=0;i<15;i++){c.strokeStyle=`rgba(50,50,50,.25)`;c.lineWidth=1;c.beginPath();c.moveTo(R()*S,R()*S);c.lineTo(R()*S,R()*S);c.stroke()}
      break;
    case 4: // Wood
      c.fillStyle='#6d4523'; c.fillRect(0,0,S,S);
      for(let y=0;y<S;y+=2){c.fillStyle=`rgba(${70+R()*50|0},${45+R()*25|0},${20+R()*18|0},.35)`;c.fillRect(0,y,S,1)}
      for(let i=0;i<120;i++){c.fillStyle='rgba(40,25,10,.2)';c.fillRect(R()*S|0,R()*S|0,1,3+R()*5|0)}
      break;
    case 5: // Leaves
      c.fillStyle='#2b7a2b'; c.fillRect(0,0,S,S);
      for(let i=0;i<600;i++){c.fillStyle=`rgba(${15+R()*60|0},${70+R()*110|0},${15+R()*45|0},.55)`;c.fillRect(R()*S|0,R()*S|0,3+R()*5|0,3+R()*5|0)}
      for(let i=0;i<50;i++){c.fillStyle='rgba(0,35,0,.25)';c.fillRect(R()*S|0,R()*S|0,2,2)}
      break;
    case 6: // Sand
      c.fillStyle='#d4ba6a'; c.fillRect(0,0,S,S);
      for(let i=0;i<900;i++){const v=170+R()*70|0;c.fillStyle=`rgb(${v},${v-15|0},${v-55|0})`;c.fillRect(R()*S|0,R()*S|0,1,1)}
      break;
    case 7: // Water
      c.fillStyle='rgba(35,90,190,.55)'; c.fillRect(0,0,S,S);
      for(let i=0;i<120;i++){c.fillStyle='rgba(55,130,240,.25)';c.fillRect(R()*S|0,R()*S|0,5+R()*10|0,1)}
      break;
    case 8: // Planks
      c.fillStyle='#a08050'; c.fillRect(0,0,S,S);
      for(let i=0;i<4;i++){const y=i*16;c.strokeStyle='rgba(70,45,15,.25)';c.lineWidth=1;c.strokeRect(0,y,S,16);
      for(let j=0;j<50;j++){c.fillStyle=`rgba(${130+R()*45|0},${95+R()*40|0},${55+R()*35|0},.3)`;c.fillRect(R()*S|0,y+R()*16|0,1,2)}}
      break;
    case 9: // Brick
      c.fillStyle='#a04030'; c.fillRect(0,0,S,S);
      c.strokeStyle='#c0b090'; c.lineWidth=2;
      for(let row=0;row<8;row++){const y=row*8;c.strokeRect(0,y,S,8);const off=row%2?8:0;for(let col=0;col<4;col++)c.strokeRect(off+col*16,y,16,8)}
      for(let i=0;i<250;i++){c.fillStyle=`rgba(${130+R()*70|0},${40+R()*35|0},${25+R()*25|0},.25)`;c.fillRect(R()*S|0,R()*S|0,2,2)}
      break;
    case 10: // Cobblestone
      c.fillStyle='#707070'; c.fillRect(0,0,S,S);
      for(let i=0;i<30;i++){const bx=R()*S|0,by=R()*S|0,bw=5+R()*12|0,bh=5+R()*12|0;const v=65+R()*85|0;c.fillStyle=`rgb(${v},${v},${v})`;c.fillRect(bx,by,bw,bh);c.strokeStyle='rgba(35,35,35,.35)';c.lineWidth=1;c.strokeRect(bx,by,bw,bh)}
      break;
  }

  const tex = new THREE.CanvasTexture(cv);
  tex.magFilter = THREE.NearestFilter;
  tex.minFilter = THREE.NearestFilter;
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  _tc[id] = tex;
  return tex;
}

function blockTexIds(bt) {
  // [+x, -x, +y, -y, +z, -z]
  switch(bt) {
    case 1: return [11,11,1,2,11,11];
    default: return [bt,bt,bt,bt,bt,bt];
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NOISE GENERATOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class SimplexNoise {
  constructor(seed) {
    this.p = new Uint8Array(512);
    let s = seed || 1;
    const next = () => { s = (s * 16807) % 2147483647; return (s & 0x7fffffff) / 0x7fffffff; };
    const perm = new Uint8Array(256);
    for (let i = 0; i < 256; i++) perm[i] = i;
    for (let i = 255; i > 0; i--) { const j = next() * i | 0; [perm[i], perm[j]] = [perm[j], perm[i]]; }
    for (let i = 0; i < 512; i++) this.p[i] = perm[i & 255];
  }
  _fade(t) { return t * t * (3 - 2 * t); }
  _hash(x, y) { return this.p[(this.p[x & 255] + y) & 511] / 255; }
  _lerp(a, b, t) { return a + t * (b - a); }
  noise2(x, y) {
    const ix = Math.floor(x), iy = Math.floor(y);
    const fx = this._fade(x - ix), fy = this._fade(y - iy);
    return this._lerp(
      this._lerp(this._hash(ix, iy), this._hash(ix + 1, iy), fx),
      this._lerp(this._hash(ix, iy + 1), this._hash(ix + 1, iy + 1), fx), fy
    );
  }
  fbm(x, y, octaves = 4) {
    let val = 0, amp = 0.5, freq = 1, max = 0;
    for (let i = 0; i < octaves; i++) {
      val += this.noise2(x * freq, y * freq) * amp;
      max += amp; amp *= 0.5; freq *= 2;
    }
    return val / max;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  THREE.JS SETUP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const renderer = new THREE.WebGLRenderer({ antialias: !MOBILE, powerPreference: 'high-performance' });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, MOBILE ? 1.5 : 2));
renderer.setClearColor(0x7ec8e3);
if (!MOBILE) {
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
}
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x7ec8e3, 30, RENDER_DIST * CS + 20);
const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 350);

// Lighting
scene.add(new THREE.HemisphereLight(0x87ceeb, 0x556b2f, 0.55));
scene.add(new THREE.AmbientLight(0xffffff, 0.3));
const sun = new THREE.DirectionalLight(0xfff5e0, 0.95);
sun.position.set(50, 90, 35);
if (!MOBILE) {
  sun.castShadow = true;
  const sc = sun.shadow.camera;
  sun.shadow.mapSize.set(1024, 1024);
  sc.near = 1; sc.far = 250; sc.left = sc.bottom = -70; sc.right = sc.top = 70;
}
scene.add(sun);

// Sky dome
const skyMat = new THREE.ShaderMaterial({
  side: THREE.BackSide,
  vertexShader: `varying vec3 vP;void main(){vP=position;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.);}`,
  fragmentShader: `varying vec3 vP;void main(){float h=normalize(vP).y;vec3 a=vec3(.48,.73,.95);vec3 b=vec3(.78,.90,1.);gl_FragColor=vec4(mix(b,a,max(h,0.)),1.);}`
});
const skyMesh = new THREE.Mesh(new THREE.SphereGeometry(220, 16, 16), skyMat);
scene.add(skyMesh);

// Sun visual
const sunVis = new THREE.Mesh(new THREE.SphereGeometry(5, 10, 10), new THREE.MeshBasicMaterial({ color: 0xffee88 }));
sunVis.position.copy(sun.position);
scene.add(sunVis);

// Clouds
const cloudGroup = new THREE.Group(); scene.add(cloudGroup);
const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.55 });
for (let i = 0; i < 22; i++) {
  const cg = new THREE.Group();
  const n = 3 + Math.random() * 5 | 0;
  for (let j = 0; j < n; j++) {
    const s = 3 + Math.random() * 6;
    const cm = new THREE.Mesh(new THREE.BoxGeometry(s, 1, s * 0.6), cloudMat);
    cm.position.set(j * 3 - n, 0, (Math.random() - 0.5) * 3);
    cg.add(cm);
  }
  cg.position.set((Math.random() - 0.5) * 200, 50 + Math.random() * 15, (Math.random() - 0.5) * 200);
  cloudGroup.add(cg);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WORLD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let worldSeed = 42;
let noise = new SimplexNoise(worldSeed);
const blockHistory = []; // for sync to new players

class World {
  constructor() { this.chunks = new Map(); this.meshes = new Map(); this.dirty = new Set(); }
  _k(cx, cz) { return cx + ',' + cz; }
  _i(lx, ly, lz) { return ly * CS * CS + lz * CS + lx; }

  getChunk(cx, cz) {
    const k = this._k(cx, cz);
    if (!this.chunks.has(k)) this._generate(cx, cz);
    return this.chunks.get(k);
  }

  _generate(cx, cz) {
    const k = this._k(cx, cz);
    const d = new Uint8Array(CS * CS * CH);
    const WATER_LVL = 10;

    for (let lx = 0; lx < CS; lx++) {
      for (let lz = 0; lz < CS; lz++) {
        const wx = cx * CS + lx, wz = cz * CS + lz;
        const h1 = noise.fbm(wx * 0.008, wz * 0.008, 5);
        const h2 = noise.fbm(wx * 0.03, wz * 0.03, 3) * 0.25;
        const h3 = noise.fbm(wx * 0.06, wz * 0.06, 2) * 0.1;
        let h = Math.floor((h1 + h2 + h3) * 22 + 14);
        h = Math.max(1, Math.min(CH - 3, h));

        for (let ly = 0; ly < CH; ly++) {
          let b = 0;
          if (ly === 0) b = 3;
          else if (ly < h - 4) b = 3;
          else if (ly < h) b = 2;
          else if (ly === h) b = h <= WATER_LVL + 1 ? 6 : 1;
          else if (ly <= WATER_LVL && ly > h) b = 7;
          d[this._i(lx, ly, lz)] = b;
        }

        // Trees
        if (h > WATER_LVL + 2 && noise.noise2(wx * 0.47, wz * 0.47) > 0.77) {
          const th = 4 + Math.floor(noise.noise2(wx * 3.1, wz * 3.1) * 3);
          for (let ty = 1; ty <= th; ty++) {
            const by = h + ty;
            if (by < CH) d[this._i(lx, by, lz)] = 4;
          }
          const canopyBase = h + th - 1;
          for (let dx = -2; dx <= 2; dx++) {
            for (let dz = -2; dz <= 2; dz++) {
              for (let dy = 0; dy <= 2; dy++) {
                if (Math.abs(dx) === 2 && Math.abs(dz) === 2 && dy === 2) continue;
                const nx = lx + dx, nz = lz + dz, ny = canopyBase + dy;
                if (nx >= 0 && nx < CS && nz >= 0 && nz < CS && ny < CH) {
                  if (d[this._i(nx, ny, nz)] === 0) d[this._i(nx, ny, nz)] = 5;
                }
              }
            }
          }
        }
      }
    }
    this.chunks.set(k, d);
    this.dirty.add(k);
  }

  getBlock(wx, wy, wz) {
    if (wy < 0 || wy >= CH) return 0;
    const cx = Math.floor(wx / CS), cz = Math.floor(wz / CS);
    const lx = ((wx % CS) + CS) % CS, lz = ((wz % CS) + CS) % CS;
    return this.getChunk(cx, cz)[this._i(lx, wy, lz)];
  }

  setBlock(wx, wy, wz, b) {
    if (wy < 0 || wy >= CH) return;
    const cx = Math.floor(wx / CS), cz = Math.floor(wz / CS);
    const lx = ((wx % CS) + CS) % CS, lz = ((wz % CS) + CS) % CS;
    this.getChunk(cx, cz)[this._i(lx, wy, lz)] = b;
    const k = this._k(cx, cz);
    this.dirty.add(k);
    if (lx === 0) this.dirty.add(this._k(cx - 1, cz));
    if (lx === CS - 1) this.dirty.add(this._k(cx + 1, cz));
    if (lz === 0) this.dirty.add(this._k(cx, cz - 1));
    if (lz === CS - 1) this.dirty.add(this._k(cx, cz + 1));
  }

  isSolid(wx, wy, wz) {
    const b = this.getBlock(wx, wy, wz);
    return BT[b] ? BT[b].s : false;
  }

  buildMesh(cx, cz) {
    const k = this._k(cx, cz), data = this.getChunk(cx, cz);
    // Remove old
    if (this.meshes.has(k)) {
      const old = this.meshes.get(k);
      scene.remove(old);
      old.children.forEach(ch => { ch.geometry.dispose(); ch.material.dispose(); });
      this.meshes.delete(k);
    }

    const FACES = [
      { d:[1,0,0], c:[[1,0,0],[1,1,0],[1,1,1],[1,0,1]], n:[1,0,0], fi:0, uv:[[0,0],[0,1],[1,1],[1,0]] },
      { d:[-1,0,0], c:[[0,0,1],[0,1,1],[0,1,0],[0,0,0]], n:[-1,0,0], fi:1, uv:[[0,0],[0,1],[1,1],[1,0]] },
      { d:[0,1,0], c:[[0,1,1],[1,1,1],[1,1,0],[0,1,0]], n:[0,1,0], fi:2, uv:[[0,0],[1,0],[1,1],[0,1]] },
      { d:[0,-1,0], c:[[0,0,0],[1,0,0],[1,0,1],[0,0,1]], n:[0,-1,0], fi:3, uv:[[0,0],[1,0],[1,1],[0,1]] },
      { d:[0,0,1], c:[[0,0,1],[1,0,1],[1,1,1],[0,1,1]], n:[0,0,1], fi:4, uv:[[0,0],[1,0],[1,1],[0,1]] },
      { d:[0,0,-1], c:[[1,0,0],[0,0,0],[0,1,0],[1,1,0]], n:[0,0,-1], fi:5, uv:[[0,0],[1,0],[1,1],[0,1]] },
    ];

    const buckets = {}; // texId -> {p,n,u,idx,vi}

    for (let ly = 0; ly < CH; ly++) {
      for (let lz = 0; lz < CS; lz++) {
        for (let lx = 0; lx < CS; lx++) {
          const bl = data[this._i(lx, ly, lz)];
          if (bl === 0) continue;
          const tids = blockTexIds(bl);
          const wx = cx * CS + lx, wz = cz * CS + lz;

          for (const f of FACES) {
            const nx = wx + f.d[0], ny = ly + f.d[1], nz = wz + f.d[2];
            const nb = this.getBlock(nx, ny, nz);
            if (nb !== 0 && !(bl !== 7 && nb === 7)) continue;
            if (bl === 7 && nb === 7) continue;

            const tid = tids[f.fi];
            if (!buckets[tid]) buckets[tid] = { p:[], n:[], u:[], idx:[], vi:0 };
            const bk = buckets[tid];

            // AO-like shading based on face direction
            const shade = f.d[1] === 1 ? 1.0 : f.d[1] === -1 ? 0.65 : f.d[0] !== 0 ? 0.8 : 0.88;

            for (let i = 0; i < 4; i++) {
              bk.p.push(lx + f.c[i][0], ly + f.c[i][1], lz + f.c[i][2]);
              bk.n.push(f.n[0] * shade, f.n[1] * shade, f.n[2] * shade);
              bk.u.push(f.uv[i][0], f.uv[i][1]);
            }
            bk.idx.push(bk.vi, bk.vi + 1, bk.vi + 2, bk.vi, bk.vi + 2, bk.vi + 3);
            bk.vi += 4;
          }
        }
      }
    }

    const group = new THREE.Group();
    group.position.set(cx * CS, 0, cz * CS);

    for (const tid in buckets) {
      const bk = buckets[tid];
      if (!bk.p.length) continue;
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(bk.p, 3));
      geo.setAttribute('normal', new THREE.Float32BufferAttribute(bk.n, 3));
      geo.setAttribute('uv', new THREE.Float32BufferAttribute(bk.u, 2));
      geo.setIndex(bk.idx);
      const isWater = parseInt(tid) === 7;
      const mat = new THREE.MeshLambertMaterial({
        map: mkTex(parseInt(tid)),
        transparent: isWater,
        opacity: isWater ? 0.55 : 1.0,
      });
      const mesh = new THREE.Mesh(geo, mat);
      if (!MOBILE) { mesh.castShadow = true; mesh.receiveShadow = true; }
      group.add(mesh);
    }

    scene.add(group);
    this.meshes.set(k, group);
  }

  update(px, pz) {
    const pcx = Math.floor(px / CS), pcz = Math.floor(pz / CS);
    const needed = new Set();

    for (let dx = -RENDER_DIST; dx <= RENDER_DIST; dx++) {
      for (let dz = -RENDER_DIST; dz <= RENDER_DIST; dz++) {
        if (dx * dx + dz * dz > (RENDER_DIST + 0.5) * (RENDER_DIST + 0.5)) continue;
        const cx = pcx + dx, cz = pcz + dz;
        const k = this._k(cx, cz);
        needed.add(k);
        this.getChunk(cx, cz);
      }
    }

    let built = 0;
    for (const k of this.dirty) {
      if (!needed.has(k)) continue;
      const [cx, cz] = k.split(',').map(Number);
      this.buildMesh(cx, cz);
      this.dirty.delete(k);
      if (++built >= 3) break;
    }

    // Unload far chunks
    for (const [k, m] of this.meshes) {
      if (!needed.has(k)) {
        scene.remove(m);
        m.children.forEach(ch => { ch.geometry.dispose(); ch.material.dispose(); });
        this.meshes.delete(k);
      }
    }
  }
}

let world = new World();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PLAYER CONTROLLER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class Player {
  constructor() {
    this.pos = new THREE.Vector3(8, 30, 8);
    this.vel = new THREE.Vector3();
    this.yaw = 0;
    this.pitch = 0;
    this.grounded = false;
    this.slot = 0;
    this._spawn();
  }

  _spawn() {
    for (let y = CH - 1; y >= 0; y--) {
      if (world.isSolid(8, y, 8)) { this.pos.y = y + 1 + EYE_H; return; }
    }
    this.pos.y = 20 + EYE_H;
  }

  eye() { return this.pos.clone(); }
  forward() {
    return new THREE.Vector3(
      -Math.sin(this.yaw) * Math.cos(this.pitch),
      Math.sin(this.pitch),
      -Math.cos(this.yaw) * Math.cos(this.pitch)
    ).normalize();
  }

  update(dt, input, jump) {
    const fwd = new THREE.Vector3(-Math.sin(this.yaw), 0, -Math.cos(this.yaw));
    const right = new THREE.Vector3(Math.cos(this.yaw), 0, -Math.sin(this.yaw));
    const mv = new THREE.Vector3();
    mv.addScaledVector(fwd, input.z);
    mv.addScaledVector(right, input.x);
    if (mv.lengthSq() > 0) mv.normalize();

    this.vel.x = mv.x * MOVE_SPEED;
    this.vel.z = mv.z * MOVE_SPEED;
    this.vel.y -= GRAVITY * dt;

    if (jump && this.grounded) { this.vel.y = JUMP_VEL; this.grounded = false; }

    const np = this.pos.clone();
    np.x += this.vel.x * dt;
    np.y += this.vel.y * dt;
    np.z += this.vel.z * dt;

    this._collide(np);
    this.pos.copy(np);

    camera.position.copy(this.eye());
    camera.lookAt(this.eye().add(this.forward()));
  }

  _collide(np) {
    const r = BODY_R;
    this.grounded = false;

    // Y axis
    if (this.vel.y < 0) {
      const fy = Math.floor(np.y - EYE_H);
      if (this._checkXZ(np.x, fy, np.z, r)) {
        np.y = fy + 1 + EYE_H;
        this.vel.y = 0;
        this.grounded = true;
      }
    } else if (this.vel.y > 0) {
      const hy = Math.floor(np.y + 0.15);
      if (this._checkXZ(np.x, hy, np.z, r)) {
        np.y = hy - 0.15;
        this.vel.y = 0;
      }
    }

    // X axis
    const baseY = Math.floor(np.y - EYE_H);
    for (let dy = 0; dy <= Math.ceil(EYE_H); dy++) {
      const cy = baseY + dy;
      if (world.isSolid(Math.floor(np.x + r), cy, Math.floor(np.z)) ||
          world.isSolid(Math.floor(np.x - r), cy, Math.floor(np.z))) {
        np.x = this.pos.x; this.vel.x = 0; break;
      }
    }

    // Z axis
    for (let dy = 0; dy <= Math.ceil(EYE_H); dy++) {
      const cy = baseY + dy;
      if (world.isSolid(Math.floor(np.x), cy, Math.floor(np.z + r)) ||
          world.isSolid(Math.floor(np.x), cy, Math.floor(np.z - r))) {
        np.z = this.pos.z; this.vel.z = 0; break;
      }
    }

    // Floor clamp
    if (np.y < 1 + EYE_H) { np.y = 1 + EYE_H; this.vel.y = 0; this.grounded = true; }
  }

  _checkXZ(x, y, z, r) {
    return world.isSolid(Math.floor(x - r), y, Math.floor(z - r)) ||
           world.isSolid(Math.floor(x + r), y, Math.floor(z - r)) ||
           world.isSolid(Math.floor(x - r), y, Math.floor(z + r)) ||
           world.isSolid(Math.floor(x + r), y, Math.floor(z + r));
  }
}

let player;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RAYCASTING & BLOCK ACTIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function raycast(maxDist = 7) {
  const origin = player.eye(), dir = player.forward();
  let prev = null;
  for (let t = 0; t < maxDist; t += 0.04) {
    const px = Math.floor(origin.x + dir.x * t);
    const py = Math.floor(origin.y + dir.y * t);
    const pz = Math.floor(origin.z + dir.z * t);
    if (world.isSolid(px, py, pz)) return { hit: { x: px, y: py, z: pz }, place: prev };
    prev = { x: px, y: py, z: pz };
  }
  return null;
}

// Highlight cube
const hlMesh = new THREE.Mesh(
  new THREE.BoxGeometry(1.005, 1.005, 1.005),
  new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.4 })
);
hlMesh.visible = false;
scene.add(hlMesh);

function doBreak() {
  const r = raycast();
  if (r && r.hit) {
    world.setBlock(r.hit.x, r.hit.y, r.hit.z, 0);
    broadcastBlock(r.hit.x, r.hit.y, r.hit.z, 0);
  }
}

function doPlace() {
  const r = raycast();
  if (r && r.place) {
    const bt = HOTBAR_BLOCKS[player.slot];
    // Don't place inside player
    const p = player.pos, fx = Math.floor(p.x), fz = Math.floor(p.z), fy = Math.floor(p.y - EYE_H);
    if (r.place.x === fx && r.place.z === fz && r.place.y >= fy && r.place.y <= fy + Math.ceil(EYE_H)) return;
    world.setBlock(r.place.x, r.place.y, r.place.z, bt);
    broadcastBlock(r.place.x, r.place.y, r.place.z, bt);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  REMOTE PLAYERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const remotes = new Map();

function makePlayerModel(nick, color) {
  const g = new THREE.Group();
  const c = new THREE.Color(color);
  const bodyMat = new THREE.MeshLambertMaterial({ color: c });
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.2, 0.4), bodyMat);
  g.add(body);

  const headMat = new THREE.MeshLambertMaterial({ color: c.clone().multiplyScalar(1.15) });
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), headMat);
  head.position.y = 0.85;
  g.add(head);

  // Eyes
  const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.08, 0.02), eyeMat);
  eyeL.position.set(-0.12, 0.9, -0.26);
  g.add(eyeL);
  const eyeR = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.08, 0.02), eyeMat);
  eyeR.position.set(0.12, 0.9, -0.26);
  g.add(eyeR);
  const pupilMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
  const pupilL = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.02), pupilMat);
  pupilL.position.set(-0.12, 0.89, -0.27);
  g.add(pupilL);
  const pupilR = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.02), pupilMat);
  pupilR.position.set(0.12, 0.89, -0.27);
  g.add(pupilR);

  const limbMat = new THREE.MeshLambertMaterial({ color: c.clone().multiplyScalar(0.75) });
  const la = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.9, 0.3), limbMat);
  la.position.set(-0.42, -0.05, 0); g.add(la);
  const ra = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.9, 0.3), limbMat);
  ra.position.set(0.42, -0.05, 0); g.add(ra);
  const ll = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.8, 0.3), limbMat.clone());
  ll.position.set(-0.16, -1.0, 0); g.add(ll);
  const rl = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.8, 0.3), limbMat.clone());
  rl.position.set(0.16, -1.0, 0); g.add(rl);

  // Nametag
  const cv = document.createElement('canvas');
  cv.width = 256; cv.height = 48;
  const ctx = cv.getContext('2d');
  ctx.fillStyle = 'rgba(0,0,0,.6)';
  ctx.beginPath(); ctx.roundRect(0, 0, 256, 48, 10); ctx.fill();
  ctx.font = 'bold 24px Segoe UI,Arial';
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(nick || 'Player', 128, 26);
  const tex = new THREE.CanvasTexture(cv);
  const label = new THREE.Mesh(
    new THREE.PlaneGeometry(2, 0.4),
    new THREE.MeshBasicMaterial({ map: tex, transparent: true, depthTest: false })
  );
  label.position.y = 1.7;
  g.add(label);

  scene.add(g);
  return { group: g, la, ra, ll, rl, label, prevPos: new THREE.Vector3(), isMoving: false };
}

function updateRemote(id, d) {
  if (!remotes.has(id)) {
    remotes.set(id, makePlayerModel(d.nick, d.color));
  }
  const rp = remotes.get(id);
  const target = new THREE.Vector3(d.x, d.y, d.z);
  rp.isMoving = target.distanceTo(rp.prevPos) > 0.04;
  rp.prevPos.copy(target);
  rp.group.position.lerp(target, 0.25);
  rp.group.rotation.y = d.yaw || 0;

  // Limb animation
  if (rp.isMoving) {
    const sw = Math.sin(performance.now() * 0.008) * 0.55;
    rp.ll.rotation.x = sw; rp.rl.rotation.x = -sw;
    rp.la.rotation.x = -sw * 0.6; rp.ra.rotation.x = sw * 0.6;
  } else {
    rp.ll.rotation.x = rp.rl.rotation.x = rp.la.rotation.x = rp.ra.rotation.x = 0;
  }
  rp.label.lookAt(camera.position);
}

function removeRemote(id) {
  if (remotes.has(id)) {
    scene.remove(remotes.get(id).group);
    remotes.delete(id);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NETWORKING â€” PeerJS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let peer = null, isHost = false, conns = [];
let myNick = 'Steve', myColor = '#58d68d', roomId = '';
let gameActive = false, isPaused = false;

const statusBar = document.getElementById('statusBar');
const reconnectOverlay = document.getElementById('reconnectOverlay');

function genId() {
  const c = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let s = '';
  for (let i = 0; i < 4; i++) s += c[Math.random() * c.length | 0];
  return s;
}

function genColor() {
  const hues = [0, 30, 60, 120, 180, 210, 270, 330];
  const h = hues[Math.random() * hues.length | 0];
  return `hsl(${h},65%,55%)`;
}

function broadcast(msg) {
  const s = JSON.stringify(msg);
  conns.forEach(c => { if (c.open) c.send(s); });
}

function broadcastBlock(x, y, z, b) {
  if (gameActive) blockHistory.push({ x, y, z, b });
  broadcast({ t: 'blk', x, y, z, b });
}

function setupConn(conn, incoming) {
  conn.on('open', () => {
    conns.push(conn);
    updNetCount();

    if (isHost && incoming) {
      // Send world seed + block history
      conn.send(JSON.stringify({ t: 'world', seed: worldSeed, hist: blockHistory }));
      // Notify all
      const nick = conn.metadata?.nick || 'Player';
      const joinMsg = { t: 'join', nick };
      conns.forEach(c => { if (c.open) c.send(JSON.stringify(joinMsg)); });
      addChat('âš¡', nick + ' Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ»ÑÑ', '#58d68d');
    }
  });

  conn.on('data', raw => {
    let msg;
    try { msg = typeof raw === 'string' ? JSON.parse(raw) : raw; } catch { return; }
    handleMsg(msg, conn.peer);
  });

  conn.on('close', () => {
    conns = conns.filter(c => c !== conn);
    removeRemote(conn.peer);
    updNetCount();
    if (isHost) {
      const nick = conn.metadata?.nick || 'Player';
      broadcast({ t: 'left', id: conn.peer, nick });
      addChat('âš¡', nick + ' Ğ¾Ñ‚ĞºĞ»ÑÑ‡Ğ¸Ğ»ÑÑ', '#e74c3c');
    }
  });

  conn.on('error', err => {
    console.warn('Connection error:', err);
    if (!isHost) {
      reconnectOverlay.style.display = 'block';
      setTimeout(() => { reconnectOverlay.style.display = 'none'; }, 4000);
    }
  });
}

function handleMsg(msg, fromId) {
  switch (msg.t) {
    case 'pos':
      updateRemote(fromId, msg);
      if (isHost) {
        const relay = JSON.stringify(msg);
        conns.forEach(c => { if (c.open && c.peer !== fromId) c.send(relay); });
      }
      break;

    case 'blk':
      world.setBlock(msg.x, msg.y, msg.z, msg.b);
      if (gameActive) blockHistory.push({ x: msg.x, y: msg.y, z: msg.z, b: msg.b });
      if (isHost) {
        const relay = JSON.stringify(msg);
        conns.forEach(c => { if (c.open && c.peer !== fromId) c.send(relay); });
      }
      break;

    case 'chat':
      addChat(msg.nick, msg.text, msg.color);
      if (isHost) {
        const relay = JSON.stringify(msg);
        conns.forEach(c => { if (c.open && c.peer !== fromId) c.send(relay); });
      }
      break;

    case 'world':
      worldSeed = msg.seed;
      noise = new SimplexNoise(worldSeed);
      world = new World();
      if (msg.hist) {
        for (const h of msg.hist) {
          world.getChunk(Math.floor(h.x / CS), Math.floor(h.z / CS));
          // Apply directly without triggering history
          const cx = Math.floor(h.x / CS), cz = Math.floor(h.z / CS);
          const lx = ((h.x % CS) + CS) % CS, lz = ((h.z % CS) + CS) % CS;
          world.getChunk(cx, cz)[world._i(lx, h.y, lz)] = h.b;
          world.dirty.add(world._k(cx, cz));
        }
      }
      break;

    case 'join':
      addChat('âš¡', msg.nick + ' Ğ¿Ñ€Ğ¸ÑĞ¾ĞµĞ´Ğ¸Ğ½Ğ¸Ğ»ÑÑ', '#58d68d');
      break;

    case 'left':
      removeRemote(msg.id);
      addChat('âš¡', msg.nick + ' Ğ¾Ñ‚ĞºĞ»ÑÑ‡Ğ¸Ğ»ÑÑ', '#e74c3c');
      break;
  }
}

function updNetCount() {
  const n = 1 + conns.filter(c => c.open).length;
  document.getElementById('netText').textContent = 'ğŸ‘¤ ' + n;
  document.getElementById('playerList').textContent = 'Ğ˜Ğ³Ñ€Ğ¾ĞºĞ¾Ğ² Ğ² ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ğµ: ' + n;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CHAT SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const chatLog = document.getElementById('chatLog');
const chatInputBox = document.getElementById('chatInputBox');
const chatInput = document.getElementById('chatInput');
const chatBtn = document.getElementById('chatBtn');
let chatVisible = false;

function addChat(nick, text, color) {
  const el = document.createElement('div');
  el.className = 'cmsg';
  el.innerHTML = `<span class="cn" style="color:${color || '#58d68d'}">${nick}:</span> ${text.replace(/</g, '&lt;')}`;
  chatLog.appendChild(el);
  chatLog.scrollTop = chatLog.scrollHeight;
  while (chatLog.children.length > 60) chatLog.removeChild(chatLog.firstChild);
}

function sendChat(text) {
  if (!text.trim()) return;
  addChat(myNick, text, myColor);
  broadcast({ t: 'chat', nick: myNick, text, color: myColor });
}

function toggleChat() {
  chatVisible = !chatVisible;
  chatInputBox.style.display = chatVisible ? 'block' : 'none';
  if (chatVisible) chatInput.focus();
  else { chatInput.blur(); chatInput.value = ''; }
}

chatInput.addEventListener('keydown', e => {
  e.stopPropagation();
  if (e.key === 'Enter') { sendChat(chatInput.value); toggleChat(); }
  if (e.key === 'Escape') toggleChat();
});
chatBtn.addEventListener('click', toggleChat);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INPUT HANDLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const keys = {};
const moveDir = { x: 0, z: 0 };
let wantJump = false, ptrLocked = false;

document.addEventListener('keydown', e => {
  if (chatVisible) return;
  keys[e.code] = true;
  if (e.code === 'Escape' && gameActive) togglePause();
  if (e.code === 'KeyT' && gameActive && !isPaused) { e.preventDefault(); toggleChat(); }
  if (e.code.startsWith('Digit') && gameActive) {
    const n = parseInt(e.code.replace('Digit', '')) - 1;
    if (n >= 0 && n < HOTBAR_BLOCKS.length) { player.slot = n; refreshHotbar(); }
  }
});
document.addEventListener('keyup', e => { if (!chatVisible) keys[e.code] = false; });

document.addEventListener('mousemove', e => {
  if (!ptrLocked || !gameActive || chatVisible) return;
  player.yaw -= e.movementX * 0.002;
  player.pitch -= e.movementY * 0.002;
  player.pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, player.pitch));
});

renderer.domElement.addEventListener('mousedown', e => {
  if (!gameActive) return;
  if (!ptrLocked && !MOBILE) { renderer.domElement.requestPointerLock(); return; }
  if (e.button === 0) doBreak();
  if (e.button === 2) doPlace();
});
renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());

document.addEventListener('pointerlockchange', () => {
  ptrLocked = document.pointerLockElement === renderer.domElement;
  if (!ptrLocked && gameActive && !MOBILE && !isPaused) showPause();
});

document.addEventListener('wheel', e => {
  if (!gameActive) return;
  player.slot = e.deltaY > 0 ? (player.slot + 1) % HOTBAR_BLOCKS.length : (player.slot - 1 + HOTBAR_BLOCKS.length) % HOTBAR_BLOCKS.length;
  refreshHotbar();
});

// â”€â”€ Mobile Touch Input â”€â”€
let joyActive = false, joyTouchId = null, joyCenter = { x: 0, y: 0 };
let camTouchId = null, camPrev = { x: 0, y: 0 };
const joyKnob = document.getElementById('joyKnob');
const joyBase = document.getElementById('joyBase');

function touchStart(e) {
  if (!gameActive) return;
  for (const t of e.changedTouches) {
    const el = document.elementFromPoint(t.clientX, t.clientY);
    if (el && (el.id === 'joyBase' || el.id === 'joyKnob' || el.id === 'joyZone')) {
      if (!joyActive) {
        joyActive = true;
        joyTouchId = t.identifier;
        const r = joyBase.getBoundingClientRect();
        joyCenter = { x: r.left + r.width / 2, y: r.top + r.height / 2 };
      }
    } else if (el && el.id === 'mbJump') { wantJump = true; }
    else if (el && el.id === 'mbBreak') { doBreak(); }
    else if (el && el.id === 'mbPlace') { doPlace(); }
    else if (!el || (!el.classList.contains('mb') && el.id !== 'joyBase' && el.id !== 'joyKnob' && !el.closest('.hs') && el.id !== 'chatBtn')) {
      if (camTouchId === null) { camTouchId = t.identifier; camPrev = { x: t.clientX, y: t.clientY }; }
    }
  }
}

function touchMove(e) {
  if (!gameActive) return;
  e.preventDefault();
  for (const t of e.changedTouches) {
    if (t.identifier === joyTouchId && joyActive) {
      const dx = t.clientX - joyCenter.x, dy = t.clientY - joyCenter.y;
      const maxR = 50, dist = Math.min(Math.sqrt(dx * dx + dy * dy), maxR);
      const ang = Math.atan2(dy, dx);
      const nx = Math.cos(ang) * dist, ny = Math.sin(ang) * dist;
      joyKnob.style.transform = `translate(calc(-50% + ${nx}px),calc(-50% + ${ny}px))`;
      moveDir.x = nx / maxR;
      moveDir.z = ny / maxR;
    }
    if (t.identifier === camTouchId) {
      player.yaw -= (t.clientX - camPrev.x) * 0.004;
      player.pitch -= (t.clientY - camPrev.y) * 0.004;
      player.pitch = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, player.pitch));
      camPrev = { x: t.clientX, y: t.clientY };
    }
  }
}

function touchEnd(e) {
  for (const t of e.changedTouches) {
    if (t.identifier === joyTouchId) {
      joyActive = false; joyTouchId = null;
      moveDir.x = moveDir.z = 0;
      joyKnob.style.transform = 'translate(-50%,-50%)';
    }
    if (t.identifier === camTouchId) camTouchId = null;
  }
  wantJump = false;
}

document.addEventListener('touchstart', touchStart, { passive: false });
document.addEventListener('touchmove', touchMove, { passive: false });
document.addEventListener('touchend', touchEnd, { passive: false });

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UI MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const menuScreen = document.getElementById('menuScreen');
const mainCard = document.getElementById('mainCard');
const joinSection = document.getElementById('joinSection');
const hudEl = document.getElementById('hud');
const mobileUI = document.getElementById('mobileUI');
const hotbarEl = document.getElementById('hotbar');
const blockNameEl = document.getElementById('blockName');
const coordsEl = document.getElementById('coords');
const inpNick = document.getElementById('inpNick');
const inpRoom = document.getElementById('inpRoom');

inpNick.value = 'Player_' + (Math.random() * 999 | 0);

function buildHotbar() {
  hotbarEl.innerHTML = '';
  HOTBAR_BLOCKS.forEach((bt, i) => {
    const s = document.createElement('div');
    s.className = 'hs' + (i === 0 ? ' active' : '');
    const cv = document.createElement('canvas');
    cv.width = cv.height = 16;
    const ctx = cv.getContext('2d');
    const tid = blockTexIds(bt)[2]; // top face
    const src = mkTex(tid).image;
    ctx.drawImage(src, 0, 0, 16, 16);
    s.appendChild(cv);
    const sn = document.createElement('span');
    sn.className = 'snum';
    sn.textContent = i + 1;
    s.appendChild(sn);
    s.addEventListener('click', () => { player.slot = i; refreshHotbar(); });
    s.addEventListener('touchstart', e => { e.stopPropagation(); player.slot = i; refreshHotbar(); }, { passive: true });
    hotbarEl.appendChild(s);
  });
}

function refreshHotbar() {
  hotbarEl.querySelectorAll('.hs').forEach((s, i) => s.classList.toggle('active', i === player.slot));
  blockNameEl.textContent = BT[HOTBAR_BLOCKS[player.slot]].n;
}

// Pause
function togglePause() { isPaused ? hidePause() : showPause(); }
function showPause() { isPaused = true; document.getElementById('pauseScreen').style.display = 'flex'; }
function hidePause() {
  isPaused = false;
  document.getElementById('pauseScreen').style.display = 'none';
  if (!MOBILE) renderer.domElement.requestPointerLock();
}
document.getElementById('btnResume').addEventListener('click', hidePause);
document.getElementById('btnQuit').addEventListener('click', () => {
  location.reload();
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MENU LOGIC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// HOST
document.getElementById('btnHost').addEventListener('click', () => {
  myNick = inpNick.value.trim() || 'Steve';
  myColor = genColor();
  roomId = genId();
  isHost = true;
  worldSeed = Math.random() * 999999 | 0;
  noise = new SimplexNoise(worldSeed);
  world = new World();

  setStatus('loading', 'Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹...');

  const peerId = 'vxc-' + roomId.toLowerCase();
  peer = new Peer(peerId, { debug: 0 });

  peer.on('open', () => {
    setStatus('ok', 'ĞšĞ¾Ğ¼Ğ½Ğ°Ñ‚Ğ° Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ°!');
    document.getElementById('roomDisplay').style.display = 'block';
    document.getElementById('roomId').textContent = roomId;
    document.getElementById('playerList').textContent = 'Ğ˜Ğ³Ñ€Ğ¾ĞºĞ¾Ğ² Ğ² ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ğµ: 1';
  });

  peer.on('connection', conn => setupConn(conn, true));

  peer.on('error', err => {
    if (err.type === 'unavailable-id') {
      roomId = genId();
      setStatus('loading', 'ID Ğ·Ğ°Ğ½ÑÑ‚, Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ ' + roomId + '...');
      peer.destroy();
      const newId = 'vxc-' + roomId.toLowerCase();
      peer = new Peer(newId, { debug: 0 });
      peer.on('open', () => {
        setStatus('ok', 'ĞšĞ¾Ğ¼Ğ½Ğ°Ñ‚Ğ° Ğ³Ğ¾Ñ‚Ğ¾Ğ²Ğ°!');
        document.getElementById('roomDisplay').style.display = 'block';
        document.getElementById('roomId').textContent = roomId;
      });
      peer.on('connection', conn => setupConn(conn, true));
    } else {
      setStatus('error', 'ĞÑˆĞ¸Ğ±ĞºĞ°: ' + err.message);
    }
  });

  peer.on('disconnected', () => {
    setStatus('loading', 'ĞŸĞµÑ€ĞµĞ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğº ÑĞµÑ€Ğ²ĞµÑ€Ñƒ...');
    peer.reconnect();
  });
});

// Copy button
document.getElementById('btnCopy').addEventListener('click', () => {
  navigator.clipboard.writeText(roomId).then(() => {
    const btn = document.getElementById('btnCopy');
    btn.textContent = 'âœ… Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾!';
    setTimeout(() => { btn.textContent = 'ğŸ“‹ ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ'; }, 2000);
  }).catch(() => {
    // Fallback
    const ta = document.createElement('textarea');
    ta.value = roomId;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    const btn = document.getElementById('btnCopy');
    btn.textContent = 'âœ… Ğ¡ĞºĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¾!';
    setTimeout(() => { btn.textContent = 'ğŸ“‹ ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ'; }, 2000);
  });
});

// Start game (host)
document.getElementById('btnStart').addEventListener('click', () => {
  launchGame();
});

// Join show
document.getElementById('btnJoinShow').addEventListener('click', () => {
  mainCard.style.display = 'none';
  joinSection.style.display = 'block';
  statusBar.textContent = '';
});

document.getElementById('btnBack').addEventListener('click', () => {
  joinSection.style.display = 'none';
  mainCard.style.display = 'block';
  statusBar.textContent = '';
});

// Connect
document.getElementById('btnConnect').addEventListener('click', () => {
  myNick = inpNick.value.trim() || 'Steve';
  myColor = genColor();
  const code = inpRoom.value.trim().toUpperCase();
  if (code.length < 3) { setStatus('error', 'Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ ĞºĞ¾Ğ´ ĞºĞ¾Ğ¼Ğ½Ğ°Ñ‚Ñ‹'); return; }
  isHost = false;

  setStatus('loading', 'ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ...');
  peer = new Peer(undefined, { debug: 0 });

  peer.on('open', () => {
    const conn = peer.connect('vxc-' + code.toLowerCase(), {
      metadata: { nick: myNick, color: myColor },
      reliable: true
    });

    conn.on('open', () => {
      conns.push(conn);
      setStatus('ok', 'ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡ĞµĞ½Ğ¾! Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ¼Ğ¸Ñ€Ğ°...');
      setTimeout(() => launchGame(), 1200);
    });

    conn.on('data', raw => {
      let msg;
      try { msg = typeof raw === 'string' ? JSON.parse(raw) : raw; } catch { return; }
      handleMsg(msg, conn.peer);
    });

    conn.on('close', () => {
      conns = conns.filter(c => c !== conn);
      removeRemote(conn.peer);
      updNetCount();
      addChat('âš¡', 'Ğ¡Ğ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ¸Ğµ Ñ Ñ…Ğ¾ÑÑ‚Ğ¾Ğ¼ Ğ¿Ğ¾Ñ‚ĞµÑ€ÑĞ½Ğ¾', '#e74c3c');
      reconnectOverlay.style.display = 'block';
      setTimeout(() => { reconnectOverlay.style.display = 'none'; }, 5000);
    });

    conn.on('error', e => {
      setStatus('error', 'ĞÑˆĞ¸Ğ±ĞºĞ°: ' + e.message);
    });
  });

  peer.on('error', err => {
    if (err.type === 'peer-unavailable') {
      setStatus('error', 'ĞšĞ¾Ğ¼Ğ½Ğ°Ñ‚Ğ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°. ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ ĞºĞ¾Ğ´.');
    } else {
      setStatus('error', 'ĞÑˆĞ¸Ğ±ĞºĞ° ÑĞµÑ‚Ğ¸: ' + err.message);
    }
  });

  peer.on('disconnected', () => {
    reconnectOverlay.style.display = 'block';
    peer.reconnect();
    setTimeout(() => { reconnectOverlay.style.display = 'none'; }, 5000);
  });
});

function setStatus(type, text) {
  const dots = { loading: 'dot-loading', ok: 'dot-ok', error: 'dot-err' };
  statusBar.innerHTML = `<span class="status-dot ${dots[type] || ''}"></span> ${text}`;
}

function launchGame() {
  gameActive = true;
  menuScreen.style.display = 'none';
  hudEl.style.display = 'block';
  if (MOBILE) { mobileUI.style.display = 'block'; chatBtn.style.display = 'block'; }
  player = new Player();
  buildHotbar();
  refreshHotbar();
  updNetCount();
  if (!MOBILE) renderer.domElement.requestPointerLock();
  addChat('ğŸŒ', 'Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ, ' + myNick + '!', '#58d68d');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let prevTime = performance.now(), netAccum = 0;

function gameLoop(now) {
  requestAnimationFrame(gameLoop);
  const dt = Math.min((now - prevTime) / 1000, 0.05);
  prevTime = now;

  if (!gameActive || isPaused) {
    renderer.render(scene, camera);
    return;
  }

  // PC keyboard input
  if (!MOBILE && !chatVisible) {
    moveDir.x = moveDir.z = 0;
    if (keys['KeyW'] || keys['ArrowUp']) moveDir.z = 1;
    if (keys['KeyS'] || keys['ArrowDown']) moveDir.z = -1;
    if (keys['KeyA'] || keys['ArrowLeft']) moveDir.x = -1;
    if (keys['KeyD'] || keys['ArrowRight']) moveDir.x = 1;
    wantJump = !!keys['Space'];
  }

  const input = MOBILE ? { x: moveDir.x, z: -moveDir.z } : { x: moveDir.x, z: moveDir.z };
  player.update(dt, input, wantJump);
  world.update(player.pos.x, player.pos.z);

  // Block highlight
  const rc = raycast();
  if (rc && rc.hit) {
    hlMesh.visible = true;
    hlMesh.position.set(rc.hit.x + 0.5, rc.hit.y + 0.5, rc.hit.z + 0.5);
  } else {
    hlMesh.visible = false;
  }

  // Network position broadcast
  netAccum += dt;
  if (netAccum >= 1 / NET_HZ) {
    netAccum = 0;
    broadcast({
      t: 'pos',
      x: player.pos.x, y: player.pos.y, z: player.pos.z,
      yaw: player.yaw,
      nick: myNick,
      color: myColor
    });
  }

  // Update remote labels to face camera
  remotes.forEach(rp => rp.label.lookAt(camera.position));

  // HUD updates
  const p = player.pos;
  coordsEl.textContent = `${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}  |  ${(1 / dt | 0)} fps`;

  // Follow player: sky, sun, light
  skyMesh.position.set(p.x, p.y, p.z);
  sunVis.position.set(p.x + 50, p.y + 90, p.z + 35);
  sun.position.set(p.x + 50, p.y + 90, p.z + 35);
  if (sun.target) { sun.target.position.copy(p); sun.target.updateMatrixWorld(); }

  // Animate clouds
  cloudGroup.children.forEach(c => {
    c.position.x += 0.3 * dt;
    if (c.position.x > 130) c.position.x = -130;
  });

  renderer.render(scene, camera);
}

requestAnimationFrame(gameLoop);

window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
